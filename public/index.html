<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- SEO Meta Tags -->
  <title>StratMinds VC | Applied AI</title>
  <meta name="description" content="StratMinds VC - Investing in the future of Applied AI. We partner with visionary founders building AI-powered solutions." />
  <meta name="keywords" content="StratMinds, venture capital, AI, applied AI, artificial intelligence, VC, investment" />

  <!-- Open Graph / Facebook / iMessage / WhatsApp -->
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://stratminds.vc/" />
  <meta property="og:title" content="StratMinds VC | Applied AI" />
  <meta property="og:description" content="Investing in the future of Applied AI. We partner with visionary founders building AI-powered solutions." />
  <meta property="og:image" content="https://stratminds.vc/og-image.jpg" />

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:url" content="https://stratminds.vc/" />
  <meta name="twitter:title" content="StratMinds VC | Applied AI" />
  <meta name="twitter:description" content="Investing in the future of Applied AI. We partner with visionary founders building AI-powered solutions." />
  <meta name="twitter:image" content="https://stratminds.vc/og-image.jpg" />

  <!-- Canonical URL (consolidates SEO for www and non-www) -->
  <link rel="canonical" href="https://stratminds.vc/" />

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="/favicon.png" />
  <link rel="apple-touch-icon" href="/favicon.png" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
      --ink: rgba(255, 255, 255, 0.88);
      --muted: rgba(255, 255, 255, 0.7);
      --soft: rgba(255, 255, 255, 0.5);
    }
    html, body { width: 100%; height: 100%; background: #000; }
    body {
      font-family: Avenir, "Avenir Next", "Avenir Next LT Pro", "Segoe UI", Arial, Helvetica, sans-serif;
      color: var(--ink);
      overflow-x: hidden;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 1;
    }
    #warpCanvas {
      width: 100%;
      height: 100%;
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 2;
      pointer-events: none;
    }
    main {
      position: relative;
      z-index: 2;
      min-height: 270vh;
      padding-top: 140vh;
    }
    .hero {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 10vh 8vw 8vh;
      pointer-events: none;
    }
    .hero-copy {
      max-width: 520px;
      text-align: center;
      font-size: clamp(14px, 1.5vw, 18px);
      line-height: 1.6;
      color: var(--muted);
      letter-spacing: 0.01em;
    }
    .hero-copy strong {
      color: var(--ink);
      font-weight: 600;
    }
    .sections {
      padding: 0 8vw 10vh;
      display: grid;
      justify-items: center;
      gap: 3.5vh;
    }
    .section {
      max-width: 980px;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
      padding-top: 4vh;
      text-align: center;
      opacity: 0;
      transform: translateY(24px);
      transition: opacity 600ms ease, transform 600ms ease;
    }
    .section.is-visible {
      opacity: 1;
      transform: translateY(0);
    }
    .section h2 {
      font-size: clamp(22px, 3.1vw, 40px);
      letter-spacing: 0.03em;
      text-transform: uppercase;
      margin-bottom: 2vh;
      color: var(--ink);
    }
    .section p {
      font-size: clamp(14px, 1.35vw, 18px);
      line-height: 1.6;
      color: var(--soft);
      max-width: 69ch;
      padding: 10px 12px;
      margin: 0 auto;
      border: none;
      border-radius: 8px;
      display: block;
      overflow: visible;
      text-align: center;
      text-wrap: balance;
    }

    .video-grid {
      margin: 3vh auto 0;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 18px;
      max-width: 314px;
      background: transparent;
      border: none;
      padding: 0;
    }
    .video-card {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-decoration: none;
      color: var(--ink);
      gap: 10px;
      cursor: pointer;
      background: transparent;
      border: none;
      padding: 0;
    }
    .video-thumb {
      position: relative;
      width: 100%;
      aspect-ratio: 16 / 9;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.35);
      background: #000;
      box-shadow: none;
      outline: none;
    }
    .video-thumb img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      border: 0;
      outline: 0;
    }
    .video-title {
      font-size: 13px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.85);
      text-align: center;
      background: transparent;
      padding: 4px 0;
      border-radius: 0;
    }
    .video-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 6;
      padding: 6vh 6vw;
    }
    .video-modal.is-open {
      display: flex;
    }
    .video-modal__panel {
      width: min(920px, 100%);
      background: #050505;
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 16px;
      padding: 16px;
    }
    .video-modal video,
    .video-modal iframe {
      width: 100%;
      aspect-ratio: 16 / 9;
      border-radius: 12px;
      display: block;
      border: none;
    }
    .video-modal__close {
      display: block;
      margin-left: auto;
      margin-bottom: 10px;
      background: transparent;
      color: var(--ink);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 12px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      cursor: pointer;
    }
    .metrics {
      margin-top: 2vh;
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 1vh 0.8vw;
      max-width: 620px;
      margin-left: auto;
      margin-right: auto;
      align-items: start;
    }
    .metric {
      border: none;
      padding: 1.6vh 1.4vw;
      min-height: 120px;
      text-align: center;
      word-break: break-word;
    }
    .metric h3 {
      font-size: clamp(16px, 1.6vw, 20px);
      margin-bottom: 0.6vh;
      white-space: normal;
      color: #3be28c;
    }
    .metric span {
      display: block;
      color: var(--soft);
      font-size: 13px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      white-space: normal;
    }
    .intro {
      position: absolute;
      inset: 0;
      z-index: 3;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      gap: 48px;
      padding-top: 20vh;
    }
    .tagline {
      position: static;
      left: auto;
      top: auto;
      transform: none;
      font-family: Avenir, "Avenir Next", "Avenir Next LT Pro", "Segoe UI", Arial, Helvetica, sans-serif;
      font-size: clamp(14px, 1.6vw, 19px);
      letter-spacing: 0.02em;
      text-transform: none;
      color: rgba(255, 255, 255, 0.92);
      text-align: center;
      pointer-events: none;
      white-space: normal;
      width: min(var(--logo-w, 72vw), 90vw);
      max-width: none;
      line-height: 1.7;
      opacity: 0;
      transition: opacity 120ms linear;
      z-index: 3;
      text-wrap: balance;
    }
    .scroll-cue {
      position: absolute;
      right: 6vw;
      bottom: 8vh;
      font-size: 12px;
      letter-spacing: 0.3em;
      text-transform: uppercase;
      color: var(--soft);
      animation: breathe 3s ease-in-out infinite;
      pointer-events: none;
    }
    .sound-toggle {
      position: fixed;
      right: 4vw;
      top: 3vh;
      z-index: 3;
      font-family: Avenir, "Avenir Next", "Avenir Next LT Pro", "Segoe UI", Arial, Helvetica, sans-serif;
      font-size: 12px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--soft);
      background: transparent;
      border: 1px solid rgba(255, 255, 255, 0.12);
      padding: 8px 12px;
      cursor: pointer;
      pointer-events: auto;
      transition: color 180ms ease, border-color 180ms ease;
    }
    .sound-toggle:hover {
      color: #3be28c;
      border-color: #3be28c;
    }
    .warp-toggle {
      position: fixed;
      left: 4vw;
      top: 3vh;
      z-index: 3;
      font-family: Avenir, "Avenir Next", "Avenir Next LT Pro", "Segoe UI", Arial, Helvetica, sans-serif;
      font-size: 12px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--soft);
      background: transparent;
      border: 1px solid rgba(255, 255, 255, 0.12);
      padding: 8px 12px;
      cursor: pointer;
      pointer-events: auto;
      transition: color 180ms ease, border-color 180ms ease;
    }
    .warp-toggle:hover {
      color: #3be28c;
      border-color: #3be28c;
    }
    .contact {
      position: static;
      display: flex;
      gap: 14px;
      z-index: 3;
      pointer-events: none;
      justify-content: center;
    }
    .contact-spacer {
      position: absolute;
      left: 50%;
      top: 0;
      transform: translateX(-50%);
      height: 18px;
      width: 1px;
      opacity: 0;
    }
    .contact a {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      color: rgba(255, 255, 255, 0.68);
      text-decoration: none;
      font-size: 16px;
      letter-spacing: 0.04em;
      line-height: 1;
      pointer-events: auto;
      transition: color 180ms ease;
    }
    .contact a:hover,
    .contact a:focus {
      color: #3be28c;
    }
    .contact a.portal {
      opacity: 0.85;
    }
    .intro-cue {
      position: relative;
      width: 14px;
      height: 12px;
      z-index: 3;
      pointer-events: none;
    }
    .intro-cue svg,
    .divider-cue svg {
      width: 100%;
      height: 100%;
      display: block;
    }
    .intro-cue svg polygon,
    .divider-cue svg polygon {
      fill: rgba(59, 226, 140, calc(1 - var(--fade, 0)));
      stroke: none;
    }
    .portfolio {
      max-width: 740px;
      margin: 8vh auto 6vh;
      color: rgba(255, 255, 255, 0.55);
      font-size: clamp(13px, 1.2vw, 16px);
      line-height: 1.7;
      text-align: center;
    }
    .portfolio .headline {
      margin: 0 auto 16px;
      font-size: clamp(14px, 1.3vw, 18px);
      color: rgba(255, 255, 255, 0.72);
      min-height: 1.4em;
      transition: opacity 200ms ease;
      opacity: 0.0;
    }
    .portfolio ul {
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: 6px;
    }
    .portfolio li {
      color: rgba(255, 255, 255, 0.45);
      transition: color 160ms ease, font-size 160ms ease;
    }
    .metric-body,
    .section p {
      color: rgba(255, 255, 255, 0.55);
      transition: color 180ms ease;
    }
    .portfolio-spacer {
      height: 12vh;
    }
    .site-footer {
      text-align: center;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.45);
      padding: 4vh 6vw 6vh;
      letter-spacing: 0.02em;
    }
    .divider-cue {
      width: 14px;
      height: 12px;
      margin: 24px auto 88px;
      opacity: 0.85;
      position: relative;
    }

    .metric--primary {
      transform: none;
    }
    .team-link {
      display: inline-block;
      margin-top: 0;
      color: var(--soft);
      font-size: 12px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      text-decoration: none;
      background: transparent;
      border: 1px solid rgba(255, 255, 255, 0.12);
      padding: 8px 12px;
      transition: color 180ms ease, border-color 180ms ease;
    }
    .team-link .arrow { color: #3be28c; }
    .team-link:hover {
      color: #3be28c !important;
      border-color: #3be28c !important;
    }
    @keyframes breathe {
      0%, 100% { opacity: 0.3; transform: translateY(0); }
      50% { opacity: 0.9; transform: translateY(-6px); }
    }
    @media (max-width: 760px) {
      .hero { padding: 12vh 7vw 8vh; }
      .scroll-cue { display: none; }
      .tagline { white-space: normal; text-align: center; max-width: 86vw; width: 86vw !important; }
      .contact-spacer { display: none; }
      .contact { gap: 12px; pointer-events: auto; }
      .contact a { font-size: 12px; }
      .metrics { grid-template-columns: 1fr; }
      .video-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); max-width: 280px; }
      .video-card { width: 100%; margin: 0; }
    }
  </style>
</head>
<body>
  <canvas id="glCanvas"></canvas>
  <canvas id="warpCanvas"></canvas>
  <button class="warp-toggle" id="warpToggle" data-ui="true">Warp On</button>
  <button class="sound-toggle" id="soundToggle" data-ui="true">Sound Off</button>
  <div class="scroll-cue" id="scrollCue">Scroll</div>
  <div class="intro" id="intro">
    <div class="tagline" id="tagline">StratMinds is a <span style="color: #3be28c;">San Francisco-based venture capital &amp; advisory firm</span> founded in 2018, built from inception for Applied AI. We pair financial upside with operational leverage for corporates and sovereign LPs, investing at the frontier where next-gen computing meets human experience.</div>
        <div class="contact" aria-label="Contact links">
      <a href="mailto:hello@stratminds.vc" aria-label="Email StratMinds" data-ui="true">email.</a>
      <a href="https://www.linkedin.com/company/stratminds-vc" target="_blank" rel="noopener noreferrer" aria-label="StratMinds on LinkedIn" data-ui="true">linkedIn.</a>
      <a href="https://stratminds.vc/swell" target="_blank" rel="noopener noreferrer" aria-label="StratMinds Events" data-ui="true">events.</a>
      <a href="https://portal.stratminds.vc/research" target="_blank" rel="noopener noreferrer" aria-label="StratMinds Research Portal" class="portal" data-ui="true">portal.</a>
    </div>
    <div class="intro-cue" aria-hidden="true"><svg viewBox="0 0 14 12" xmlns="http://www.w3.org/2000/svg"><polygon points="7,12 0,0 14,0"/></svg></div>
  </div>
  <main>
    <div class="sections">
      <section class="section">
        <h2>Purpose-Built Since 2018</h2>
        <p class="full-text">We were built for applied AI long before it became consensus. Our lead partners have shaped billion-user products at WhatsApp, Google, Roblox, IBM, and Shopify, giving founders true peer-level support across strategy, product and UX, technology stacks, and go-to-market.</p>
        <div class="metrics">
          <div class="metric"><span>Signals</span><h3>Over 1k/day</h3><p class="metric-body">StratMinds AI for real-time market analysis and trend tracking.</p></div>
          <div class="metric metric--primary"><span>Operator DNA</span><h3>2B+ Users</h3><p class="metric-body">Products built and scaled by our partner team.</p></div>
          <div class="metric"><span>Geo Edge</span><h3>San Francisco</h3><p class="metric-body">Embedded in the epicenter of AI capital, brains and startups.</p></div>
        </div>
        <a href="stratminds-team.html" class="team-link"><span class="arrow">&#9654;</span> Our Team</a>
      </section>
      <section class="section">
        <h2>Dual Investment Thesis</h2>
        <p><span style="color: #fff;">We invest in AI through a dual-thesis framework: NC × UX.</span></p>
        <p>Next-Gen Computing (NC) backs foundational breakthroughs across the applied-AI tech stack, including model routers, generative AI platforms, and commerce and compute infrastructure.</p>
        <p>User Experience (UX) invests in AI-native products with intuitive, delightful UX for both human–machine and machine–machine interactions, unlocking real-world adoption and scalable growth.</p>

        <div class="video-grid" aria-label="Featured videos">
          <button class="video-card" data-video="https://www.youtube.com/embed/HzvaneMoAIc?autoplay=1" aria-label="Play Intro to StratMinds" data-ui="true">
            <div class="video-thumb">
              <img src="media/video/Intro to StratMinds v3.1b icon.jpg" alt="Intro to StratMinds" />
            </div>
            <div class="video-title">Intro to StratMinds</div>
          </button>
          <button class="video-card" data-video="https://www.youtube.com/embed/gnlu8T1H0Js?autoplay=1" aria-label="Play Our Thesis: UX for AI" data-ui="true">
            <div class="video-thumb">
              <img src="media/video/StratMinds UX fund thesis icon.jpg" alt="Our Thesis: UX for AI" />
            </div>
            <div class="video-title">UX for AI</div>
          </button>
        </div>
      </section>
      <section class="section">
        <h2>VC + Advisory Platform</h2>
        <p><span style="color: #fff;">We unlock both financial and strategic leverage for LPs</span> by accessing high-quality deal flow, enabling strategic co-investments, and facilitating new business incubation through venture studios and joint ventures for sovereigns, corporates, and families.</p>
        <p><span style="color: #fff;">For founders, we provide hands-on support</span> across strategy, structure, product design, and engineering collaboration.</p>
      </section>
      <section class="section">
        <h2>Why Now</h2>
        <p>AI represents a structural platform shift, compounding at a pace of roughly every 3–6 months. With an <span style="color: #fff;">extraordinary concentration of innovation and capital in cities like San Francisco</span> (approximately 50% of global activity), access to high-quality early-stage deals and deep operating insight remains limited for most investors.</p>
        <p>Despite recurring concerns about an "AI bubble," early-stage opportunities are frequently mispriced and under-allocated, creating <span style="color: #fff;">a rare window for first-check advantage and outsized outcomes that are not only financial, but also strategically critical</span> for sovereign and corporate investors.</p>
      </section>
      <section class="section">
        <h2>Performance &amp; Access</h2>
        <p>AI represents a massive strategic shift for many. <span style="color: #fff;">Don't go it alone. Do AI right with StratMinds.</span></p>
        <p>Lead the way. Shape your AI investment strategy with precision. We prioritize what truly matters, partnering with you to drive next-generation AI investments and tech enablements.</p>
      </section>
    </div>
    <div class="divider-cue" aria-hidden="true"><svg viewBox="0 0 14 12" xmlns="http://www.w3.org/2000/svg"><polygon points="7,12 0,0 14,0"/></svg></div>
    <div class="portfolio" aria-label="Portfolio companies">
      <ul>
        <li>MaintainX</li>
        <li>Omnitron</li>
        <li>Anthropic</li>
        <li>Groq</li>
        <li>CareX</li>
        <li>Sonatus</li>
        <li>REC</li>
        <li>Higgsfield</li>
        <li>Swan</li>
        <li>Bit2Me</li>
        <li>OwlAI</li>
        <li>MartianAI</li>
        <li>Rand</li>
        <li>Allocations</li>
        <li>Augment</li>
        <li>GritWell</li>
        <li>Tippsy</li>
        <li>Fuelfinance</li>
        <li>ControlRooms</li>
        <li>ShapesXR</li>
        <li>Competera</li>
        <li>Portal</li>
        <li>Mirai</li>
        <li>Pickford</li>
        <li>Klarna</li>
        <li>Bnext</li>
        <li>...</li>
      </ul>
    </div>
    <div class="portfolio-spacer" aria-hidden="true"></div>
    <div class="site-footer">© 2026–Present StratMinds VC, LLC. All rights reserved.</div>
  </main>
  <script>
    const canvas = document.getElementById('glCanvas');
    const warpCanvas = document.getElementById('warpCanvas');
    const warpCtx = warpCanvas.getContext('2d');
    const imageAsset = new Image();
    let imageLoaded = false;
    imageAsset.decoding = 'async';
    imageAsset.loading = 'eager';
    const gl = canvas.getContext('webgl2', { antialias: false, alpha: false, preserveDrawingBuffer: false });

    (function primeCanvasSize() {
      const dpr = Math.min(window.devicePixelRatio || 1, 1.5);
      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      if (gl) gl.viewport(0, 0, canvas.width, canvas.height);
      warpCanvas.width = window.innerWidth;
      warpCanvas.height = window.innerHeight;
    })();

    if (!gl) {
      const ctx = canvas.getContext('2d');
      const fallback = () => {
        const w = window.innerWidth;
        const h = window.innerHeight;
        canvas.width = w;
        canvas.height = h;
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, w, h);
        if (imageLoaded) {
          drawImageCentered(ctx, imageAsset, w, h);
        } else {
          ctx.fillStyle = '#fff';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.font = `${Math.min(w * 0.22, h * 0.35)}px Georgia`;
          ctx.globalAlpha = 0.9;
          ctx.fillText('StratMinds', w / 2, h / 2);
        }
      };
      fallback();
      window.addEventListener('resize', fallback);
      throw new Error('WebGL2 not supported');
    }
    const imageData = 'media/logo/StratMinds.png';

    const vertexSrc = `#version 300 es
    precision highp float;
    const int MAX_RIPPLES = 8;
    layout(location = 0) in vec3 aTarget;
    layout(location = 1) in float aSeed;
    layout(location = 2) in float aTone;
    layout(location = 3) in vec3 aAltTarget;

    uniform float uTime;
    uniform float uConverge;
    uniform float uLock;
    uniform vec2 uHolePos;
    uniform float uHoleRadius;
    uniform float uHoleProgress;
    uniform float uScan;
    uniform float uScroll;
    uniform float uLayer;
    uniform float uCalm;
    uniform vec2 uMouse;
    uniform float uMouseStrength;
    uniform vec2 uHoldPos;
    uniform float uHoldStrength;
    uniform vec2 uRipples[MAX_RIPPLES];
    uniform float uRippleAges[MAX_RIPPLES];
    uniform float uPass;
    uniform float uPixelRatio;

    out float vTone;
    out float vHidden;
    out float vFlicker;
    out float vScan;
    out float vLayer;
    out float vHole;

    float hash(float n) { return fract(sin(n) * 43758.5453123); }
    vec3 hash3(float n) {
      return vec3(hash(n), hash(n + 13.13), hash(n + 37.77));
    }

    void main() {
      vec3 rnd = hash3(aSeed * 91.17);
      vec3 chaos = vec3(rnd.x * 2.0 - 1.0, rnd.y * 2.0 - 1.0, rnd.z * 2.0 - 1.0);
      float drift = 0.08 * uCalm;
      chaos.xy += vec2(
        sin(uTime * 0.15 + aSeed * 12.0),
        cos(uTime * 0.18 + aSeed * 8.0)
      ) * drift;

      float converge = smoothstep(0.0, 1.0, uConverge);
      float layerMask = 1.0 - step(0.5, uLayer);
      float isSubtext = step(1.5, uLayer);
      vec3 target = aTarget;
      vec3 pos = mix(chaos, target, converge);
      pos = mix(target, pos, layerMask);
      vec3 subTarget = mix(aAltTarget, target, uHoleProgress);
      pos = mix(pos, subTarget, isSubtext);

      float settle = smoothstep(0.0, 1.0, uLock);
      float microMask = mix(layerMask, 0.6, isSubtext);
      vec3 micro = vec3(
        sin(uTime * 1.6 + aSeed * 19.0),
        cos(uTime * 1.2 + aSeed * 11.0),
        0.0
      ) * 0.008 * uCalm;
      pos += micro * settle * microMask;

      vec2 textDrift = vec2(
        sin(uTime * 1.1 + aSeed * 13.0),
        cos(uTime * 1.3 + aSeed * 9.0)
      ) * 0.0016 * isSubtext * uCalm;
      pos.xy += textDrift;

      float swirl = 1.0 - converge;
      vec2 spin = vec2(cos(uTime * 1.4 + aSeed * 14.0), sin(uTime * 1.4 + aSeed * 14.0));
      vec2 toTarget = target.xy - pos.xy;
      vec2 tangent = vec2(-toTarget.y, toTarget.x);
      pos.xy += spin * 0.06 * swirl * layerMask * uCalm;
      pos.xy += tangent * 0.08 * swirl * layerMask * uCalm;

      vec2 m = (uMouse * 2.0 - 1.0);
      float md = distance(pos.xy, m);
      float hoverWave = sin(md * 22.0 - uTime * 8.0) * exp(-md * 4.0);
      vec2 hoverRipple = normalize(pos.xy - m + 0.0001) * hoverWave * 0.06 * uMouseStrength * uCalm;
      pos.xy += hoverRipple * (0.2 + 0.8 * settle) * layerMask;

      float rippleSum = 0.0;
      float rippleEnergy = 0.0;
      for (int i = 0; i < MAX_RIPPLES; i++) {
        float age = uRippleAges[i];
        if (age >= 0.0) {
          float d = distance(pos.xy, uRipples[i]);
          float wave = sin(d * 22.0 - age * 10.0);
          float amp = exp(-d * 1.6) * exp(-age * 1.12);
          rippleSum += wave * amp;
          rippleEnergy += amp;
        }
      }
      vec2 rippleDir = normalize(pos.xy + 0.0001);
      float scatter = clamp(rippleEnergy * 0.22, 0.0, 0.45) * uCalm;
      pos.xy += rippleDir * rippleSum * 0.05 * uCalm * (0.2 + 0.8 * settle) * layerMask;
      pos.xy += rippleDir * scatter * (0.2 + 0.8 * settle) * layerMask;

      float holdDist = distance(pos.xy, uHoldPos);
      float holdWave = sin(holdDist * 18.0 - uTime * 10.0) * exp(-holdDist * 1.8);
      vec2 holdDir = normalize(pos.xy - uHoldPos + 0.0001);
      float holdScatter = exp(-holdDist * 1.4) * uHoldStrength * 0.35;
      pos.xy += holdDir * holdWave * 0.12 * uHoldStrength * (0.2 + 0.8 * settle) * layerMask;
      pos.xy += holdDir * holdScatter * (0.2 + 0.8 * settle) * layerMask;

      pos.xy = mix(pos.xy, pos.xy * 0.72, uScroll);
      pos.y = mix(pos.y, pos.y + 0.35, uScroll);

      vec2 tilt = m * 0.12;
      float rx = tilt.y;
      float ry = tilt.x;
      float cosx = cos(rx);
      float sinx = sin(rx);
      float cosy = cos(ry);
      float siny = sin(ry);

      vec3 p = pos;
      p.yz = mat2(cosx, -sinx, sinx, cosx) * p.yz;
      p.xz = mat2(cosy, -siny, siny, cosy) * p.xz;
      float z = p.z * 0.65 - 0.6;
      float perspective = 1.2 / (1.2 - z);
      vec2 projected = p.xy * perspective;

      float holeDist = distance(projected, uHolePos);
      float safeRadius = max(uHoleRadius, 0.001);
      float holeMask = (1.0 - smoothstep(safeRadius * 0.7, safeRadius, holeDist)) * step(0.001, uHoleRadius);

      gl_Position = vec4(projected.x, projected.y, clamp(z, -1.0, 1.0), 1.0);
      float isConstellation = step(0.5, uLayer) * (1.0 - step(1.5, uLayer));
      float layerScale = mix(1.0, 0.65, isConstellation) * mix(1.0, 1.45, isSubtext);
      float baseSize = mix(0.55, 1.1, aTone);
      float passScale = mix(1.0, 2.4, uPass);
      gl_PointSize = baseSize * passScale * perspective * uPixelRatio * layerScale;

      float flicker = mix(1.0, 0.9 + 0.1 * sin(uTime * 6.0 + aSeed * 24.0), settle);
      vTone = aTone;
      vFlicker = flicker;
      vScan = exp(-abs(projected.y - uScan) * 8.0);
      vLayer = uLayer;
      vHole = holeMask;
      vHidden = isSubtext;
    }
    `;

    const fragmentSrc = `#version 300 es
    precision highp float;
    in float vTone;
    in float vFlicker;
    in float vScan;
    in float vLayer;
    in float vHole;
    in float vHidden;
    uniform float uPass;
    uniform float uScroll;
    out vec4 outColor;

    void main() {
      vec2 uv = gl_PointCoord - 0.5;
      float d = length(uv);
      float coreBase = smoothstep(0.32, 0.08, d);
      float haloBase = smoothstep(0.56, 0.14, d) * 0.12;
      float coreHidden = smoothstep(0.06, 0.0, d);
      float haloHidden = smoothstep(0.12, 0.01, d) * 0.008;
      float core = mix(coreBase, coreHidden, vHidden);
      float halo = mix(haloBase, haloHidden, vHidden);
      float alpha = mix(core, halo, uPass);
      float isConstellation = step(0.5, vLayer) * (1.0 - step(1.5, vLayer));
      float isHidden = step(1.5, vLayer);
      float isMain = 1.0 - step(0.5, vLayer);
      float shade = vTone * vFlicker;
      shade *= mix(1.0, 0.45, isConstellation);
      shade += vScan * 0.45 * (1.0 - isConstellation);
      shade *= max(0.0005, mix(1.0, 0.12, uScroll)) * (1.0 - isConstellation);
      vec3 baseColor = vec3(shade);
      vec3 hiddenColor = vec3(0.55, 1.0, 0.8);
      vec3 finalColor = mix(baseColor, hiddenColor, vHidden);
      float finalAlpha = alpha;
      finalAlpha *= mix(1.0, 0.4, isConstellation);
      finalAlpha *= (isMain * (1.0 - vHole) + isHidden * vHole + isConstellation);
      outColor = vec4(finalColor, finalAlpha);
    }
    `;

    function createShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    function createProgram(vsSrc, fsSrc) {
      const vs = createShader(gl.VERTEX_SHADER, vsSrc);
      const fs = createShader(gl.FRAGMENT_SHADER, fsSrc);
      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
      }
      return program;
    }

    const program = createProgram(vertexSrc, fragmentSrc);
    gl.useProgram(program);

    const uniforms = {
      time: gl.getUniformLocation(program, 'uTime'),
      converge: gl.getUniformLocation(program, 'uConverge'),
      lock: gl.getUniformLocation(program, 'uLock'),
      scan: gl.getUniformLocation(program, 'uScan'),
      scroll: gl.getUniformLocation(program, 'uScroll'),
      layer: gl.getUniformLocation(program, 'uLayer'),
      calm: gl.getUniformLocation(program, 'uCalm'),
      holePos: gl.getUniformLocation(program, 'uHolePos'),
      holeRadius: gl.getUniformLocation(program, 'uHoleRadius'),
      holeProgress: gl.getUniformLocation(program, 'uHoleProgress'),
      mouse: gl.getUniformLocation(program, 'uMouse'),
      mouseStrength: gl.getUniformLocation(program, 'uMouseStrength'),
      holdPos: gl.getUniformLocation(program, 'uHoldPos'),
      holdStrength: gl.getUniformLocation(program, 'uHoldStrength'),
      ripples: gl.getUniformLocation(program, 'uRipples[0]'),
      rippleAges: gl.getUniformLocation(program, 'uRippleAges[0]'),
      pass: gl.getUniformLocation(program, 'uPass'),
      scrollFrag: gl.getUniformLocation(program, 'uScroll'),
      pixelRatio: gl.getUniformLocation(program, 'uPixelRatio')
    };

    const layers = {
      main: null,
      hiddenText: null,
      constellation: null
    };

    let particleCount = 0;
    let isMobile = false;
    function updateIsMobile() {
      isMobile = window.matchMedia('(max-width: 768px)').matches || navigator.maxTouchPoints > 0;
    }
    updateIsMobile();
    let logoCenterCanvas = null;
    let logoRectCss = null;
    let logoMask = null;
    let logoMaskW = 0;
    let logoMaskH = 0;
    let warpMaskPoints = [];
    let hiddenTextHitAreas = null;
    let warpEnabled = true;
    let warpStars = [];
    let warpCenter = { x: 0, y: 0 };
    let warpIntensity = 0;
    let warpScroll = 0;
    let warpEngage = 0;
    let warpEngaged = false;
    let warpEngageTime = 0;
    let whooshCtx = null;
    let whooshGain = null;
    let whooshBuffer = null;
    let whooshBufferRev = null;
    let whooshActive = false;
    let whooshPendingDown = false;
    let whooshPendingUp = false;
    let whooshLoading = false;
    let startTime = performance.now();
    let mouseX = 0.5;
    let mouseY = 0.5;
    let mouseStrength = 0.0;
    let isHolding = false;
    let holdStart = 0;
    let holdX = 0.0;
    let holdY = 0.0;
    let holdReleaseTime = 0;
    let holdReleaseStrength = 0;
    let namesLockedOpen = false;  // Names stay visible after full reveal
    const MAX_RIPPLES = 8;
    const rippleLife = 2.0;
    const ripples = [];
    const ripplePositions = new Float32Array(MAX_RIPPLES * 2);
    const rippleAges = new Float32Array(MAX_RIPPLES);
    let lastTime = performance.now();
    let idleAtTopStart = 0;
    let lastScrollY = 0;
    let lastInteractionTime = performance.now();

    function createLayer(targets, seeds, tones, altTargets) {
      const vao = gl.createVertexArray();
      gl.bindVertexArray(vao);

      const targetBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, targetBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, targets, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(0);
      gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

      const seedBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, seedBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, seeds, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(1);
      gl.vertexAttribPointer(1, 1, gl.FLOAT, false, 0, 0);

      const toneBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, toneBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, tones, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(2);
      gl.vertexAttribPointer(2, 1, gl.FLOAT, false, 0, 0);

      const altBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, altBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, altTargets, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(3);
      gl.vertexAttribPointer(3, 3, gl.FLOAT, false, 0, 0);

      gl.bindVertexArray(null);
      return { vao, buffers: { targetBuffer, seedBuffer, toneBuffer, altBuffer }, count: seeds.length };
    }

    function getDeviceBudget() {
      const cores = navigator.hardwareConcurrency || 8;
      const mem = navigator.deviceMemory || 8;
      const low = cores <= 4 || mem <= 4;
      return low ? 198000 : 585000;
    }

    function getImageRect(width, height, img) {
      const baseScale = isMobile ? 0.82 : 0.68;
      const scale = Math.min(width / img.width, height / img.height) * baseScale;
      const drawW = img.width * scale;
      const drawH = img.height * scale;
      const x = (width - drawW) / 2;
      const y = Math.max(height * 0.03, (height - drawH) / 2 - drawH * 0.28 - height * 0.15);
      return { x, y, w: drawW, h: drawH };
    }

    function drawImageCentered(ctx, img, width, height) {
      const rect = getImageRect(width, height, img);
      ctx.drawImage(img, rect.x, rect.y, rect.w, rect.h);
    }

    function buildImagePoints(width, height, img) {
      const scale = 1.0;
      const c = document.createElement('canvas');
      const rawW = width * scale;
      const rawH = height * scale;
      const maxDim = 1600;
      const factor = Math.min(1, maxDim / Math.max(rawW, rawH));
      c.width = Math.floor(rawW * factor);
      c.height = Math.floor(rawH * factor);
      const ctx = c.getContext('2d');
      ctx.clearRect(0, 0, c.width, c.height);
      drawImageCentered(ctx, img, c.width, c.height);

      const data = ctx.getImageData(0, 0, c.width, c.height).data;
      const points = [];
      let minX = c.width;
      let minY = c.height;
      let maxX = 0;
      let maxY = 0;
      const step = Math.max(1, Math.floor(Math.min(c.width, c.height) / 480));
      for (let y = 0; y < c.height; y += step) {
        for (let x = 0; x < c.width; x += step) {
          const idx = (y * c.width + x) * 4;
          const r = data[idx];
          const g = data[idx + 1];
          const b = data[idx + 2];
          const lum = (r * 0.299 + g * 0.587 + b * 0.114);
          if (lum > 20) {
            const nx = (x / c.width) * 2 - 1;
            const ny = 1 - (y / c.height) * 2;
            points.push({ x: nx, y: ny });
            if (x < minX) minX = x;
            if (x > maxX) maxX = x;
            if (y < minY) minY = y;
            if (y > maxY) maxY = y;
          }
        }
      }
      const bounds = {
        topNdc: 1 - (minY / c.height) * 2,
        bottomNdc: 1 - (maxY / c.height) * 2,
        leftNdc: (minX / c.width) * 2 - 1,
        rightNdc: (maxX / c.width) * 2 - 1
      };
      return { points, bounds };
    }

    function buildTextPoints(width, height, text, options = {}) {
      const scale = options.scale || 1.1;
      const c = document.createElement('canvas');
      const rawW = width * scale;
      const rawH = height * scale;
      const maxDim = 1600;
      const factor = Math.min(1, maxDim / Math.max(rawW, rawH));
      c.width = Math.floor(rawW * factor);
      c.height = Math.floor(rawH * factor);
      const ctx = c.getContext('2d');
      ctx.clearRect(0, 0, c.width, c.height);
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      let fontSize = Math.min(c.width, c.height) * (options.sizeFactor || 0.18);
      ctx.font = `${options.weight || 600} ${fontSize}px ${options.font || 'Georgia'}`;
      const lines = String(text).split('\n');
      let measured = 0;
      for (const line of lines) {
        measured = Math.max(measured, ctx.measureText(line).width);
      }
      const maxWidth = c.width * 0.86;
      if (measured > maxWidth) {
        fontSize *= maxWidth / measured;
        ctx.font = `${options.weight || 600} ${fontSize}px ${options.font || 'Georgia'}`;
      }
      const lineHeight = fontSize * (options.lineHeight || 1.15);
      const yPos = (options.yPx ?? (c.height / 2));
      const startY = yPos - (lines.length - 1) * lineHeight * 0.5;
      lines.forEach((line, index) => {
        ctx.fillText(line, c.width / 2, startY + index * lineHeight);
      });

      const data = ctx.getImageData(0, 0, c.width, c.height).data;
      const points = [];
      const stepDiv = options.stepDiv || 500;
      const step = Math.max(1, Math.floor(Math.min(c.width, c.height) / stepDiv));
      for (let y = 0; y < c.height; y += step) {
        for (let x = 0; x < c.width; x += step) {
          const idx = (y * c.width + x) * 4;
          if (data[idx] > 20) {
            const nx = (x / c.width) * 2 - 1;
            const ny = 1 - (y / c.height) * 2;
            points.push({ x: nx, y: ny });
          }
        }
      }
      return points;
    }

    function buildColumnsTextPoints(width, height, columns, options = {}) {
      const scale = options.scale || 1.1;
      const c = document.createElement('canvas');
      const rawW = width * scale;
      const rawH = height * scale;
      const maxDim = 1600;
      const factor = Math.min(1, maxDim / Math.max(rawW, rawH));
      c.width = Math.floor(rawW * factor);
      c.height = Math.floor(rawH * factor);
      const ctx = c.getContext('2d');
      ctx.clearRect(0, 0, c.width, c.height);
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      let fontSize = Math.min(c.width, c.height) * (options.sizeFactor || 0.18);
      ctx.font = `${options.weight || 600} ${fontSize}px ${options.font || 'Georgia'}`;
      const lineHeight = fontSize * (options.lineHeight || 1.15);
      const yPos = (options.yPx ?? (c.height / 2));
      const colCount = columns.length;
      const totalWidth = c.width * (options.spreadFactor || 0.7);
      const colSpacing = totalWidth / (colCount - 1);
      const startX = (c.width - totalWidth) / 2;

      columns.forEach((col, colIndex) => {
        const lines = col.split('\n');
        const colX = startX + colIndex * colSpacing;
        const startY = yPos - (lines.length - 1) * lineHeight * 0.5;
        lines.forEach((line, lineIndex) => {
          ctx.fillText(line, colX, startY + lineIndex * lineHeight);
        });
      });

      const data = ctx.getImageData(0, 0, c.width, c.height).data;
      const points = [];
      const stepDiv = options.stepDiv || 500;
      const step = Math.max(1, Math.floor(Math.min(c.width, c.height) / stepDiv));
      for (let y = 0; y < c.height; y += step) {
        for (let x = 0; x < c.width; x += step) {
          const idx = (y * c.width + x) * 4;
          if (data[idx] > 20) {
            const nx = (x / c.width) * 2 - 1;
            const ny = 1 - (y / c.height) * 2;
            points.push({ x: nx, y: ny });
          }
        }
      }
      return points;
    }

    function computeBoundsFromPoints(points) {
      let minX = 1e9;
      let minY = 1e9;
      let maxX = -1e9;
      let maxY = -1e9;
      for (const p of points) {
        if (p.x < minX) minX = p.x;
        if (p.x > maxX) maxX = p.x;
        if (p.y < minY) minY = p.y;
        if (p.y > maxY) maxY = p.y;
      }
      return {
        leftNdc: minX,
        rightNdc: maxX,
        bottomNdc: minY,
        topNdc: maxY
      };
    }

    function buildLogoOrTextPoints(canvasW, canvasH) {
      if (imageLoaded && imageAsset && imageAsset.width > 0 && imageAsset.height > 0) {
        const result = buildImagePoints(canvasW, canvasH, imageAsset);
        return { points: result.points, bounds: result.bounds, usedImage: true };
      }
      const pts = buildTextPoints(canvasW, canvasH, 'StratMinds', {
        scale: 1.6,
        sizeFactor: 0.16,
        weight: 700,
        font: 'Georgia',
        lineHeight: 1.0,
        yPx: canvasH * 0.36 - canvasH * 0.15
      });
      const bounds = computeBoundsFromPoints(pts);
      return { points: pts, bounds, usedImage: false };
    }

    function initParticles() {
      const dpr = Math.min(window.devicePixelRatio || 1, 1.5);
      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      gl.viewport(0, 0, canvas.width, canvas.height);
      warpCanvas.width = window.innerWidth;
      warpCanvas.height = window.innerHeight;

      const result = buildLogoOrTextPoints(canvas.width, canvas.height);
      const points = result.points;
      const centerNdc = (result.bounds.topNdc + result.bounds.bottomNdc) * 0.5;
      logoCenterCanvas = (1 - (centerNdc + 1) * 0.5) * canvas.height;

      let bottomPx;
      if (result.usedImage) {
        const logoRect = getImageRect(window.innerWidth, window.innerHeight, imageAsset);
        logoRectCss = logoRect;
        bottomPx = logoRect.y + logoRect.h;
      } else {
        const bottomNdc = result.bounds.bottomNdc;
        bottomPx = (1 - (bottomNdc + 1) * 0.5) * window.innerHeight;
        const logoWidth = (result.bounds.rightNdc - result.bounds.leftNdc) * 0.5 * window.innerWidth;
        const logoHeight = (result.bounds.topNdc - result.bounds.bottomNdc) * 0.5 * window.innerHeight;
        logoRectCss = {
          x: (window.innerWidth - logoWidth) / 2,
          y: (window.innerHeight - logoHeight) / 2 - window.innerHeight * 0.15,
          w: logoWidth,
          h: logoHeight
        };
      }
      prepareLogoMask();
      initWarp();

      const introEl = document.getElementById('intro');
      const tagline = document.getElementById('tagline');
      const contact = document.querySelector('.contact');
      const spacer = document.querySelector('.contact-spacer');
      const introCue = document.querySelector('.intro-cue');
      if (introEl && tagline) {
        const padding = 48;
        introEl.style.paddingTop = `${Math.round(bottomPx + padding)}px`;
        if (result.usedImage) {
          const logoRect = getImageRect(window.innerWidth, window.innerHeight, imageAsset);
          tagline.style.setProperty('--logo-w', `${Math.round(logoRect.w - 180)}px`);
        } else {
          const logoWidth = Math.round((result.bounds.rightNdc - result.bounds.leftNdc) * 0.5 * window.innerWidth);
          tagline.style.setProperty('--logo-w', `${Math.round(logoWidth - 180)}px`);
        }
      }

      const budget = getDeviceBudget();
      particleCount = Math.min(budget, points.length * (isMobile ? 1.35 : 5.4));

      const targets = new Float32Array(particleCount * 3);
      const seeds = new Float32Array(particleCount);
      const tones = new Float32Array(particleCount);

      for (let i = 0; i < particleCount; i++) {
        const p = points[Math.floor(Math.random() * points.length)];
        const jitter = (Math.random() - 0.5) * 0.0016;
        const x = p.x + jitter;
        const y = p.y + jitter;
        targets[i * 3] = x;
        targets[i * 3 + 1] = y;
        targets[i * 3 + 2] = 0.0;
        seeds[i] = Math.random();
        tones[i] = 0.28 + Math.random() * 0.42;
      }
      layers.main = createLayer(targets, seeds, tones, targets);

      const hiddenSpreadFactor = 0.55;
      // Calculate hidden text center based on actual logo rect position
      // Must account for scale and factor used in buildColumnsTextPoints
      const hiddenScale = 1.1;
      const rawW = canvas.width * hiddenScale;
      const rawH = canvas.height * hiddenScale;
      const maxDim = 1600;
      const hiddenFactor = Math.min(1, maxDim / Math.max(rawW, rawH));
      const logoCssCenterY = logoRectCss ? (logoRectCss.y + logoRectCss.h / 2) : (window.innerHeight / 2);
      const hiddenYPx = logoCssCenterY * dpr * hiddenScale * hiddenFactor;
      const hiddenPoints = buildColumnsTextPoints(canvas.width, canvas.height, ['Richard\nJhang', 'Anton\nBorzov', 'Summer\nKim', 'Arie\nFisher'], {
        sizeFactor: isMobile ? 0.047 : 0.057,
        weight: 900,
        font: 'Arial Black, Arial, Helvetica, sans-serif',
        lineHeight: 1.12,
        stepDiv: isMobile ? 280000 : 380000,
        spreadFactor: hiddenSpreadFactor,
        yPx: hiddenYPx
      });
      // Calculate hit areas for each column in screen coordinates
      // Use the same positioning formula as buildColumnsTextPoints for accurate alignment
      const hiddenBounds = computeBoundsFromPoints(hiddenPoints);
      const screenTop = (1 - (hiddenBounds.topNdc + 1) * 0.5) * window.innerHeight;
      const screenBottom = (1 - (hiddenBounds.bottomNdc + 1) * 0.5) * window.innerHeight;
      // Calculate column centers directly (matching buildColumnsTextPoints layout)
      const spreadWidth = window.innerWidth * hiddenSpreadFactor;
      const colSpacing = spreadWidth / 3;
      const startX = (window.innerWidth - spreadWidth) / 2;
      hiddenTextHitAreas = {
        top: screenTop,
        bottom: screenBottom,
        columns: [
          { x: startX, w: colSpacing * 0.8 },
          { x: startX + colSpacing, w: colSpacing * 0.8 },
          { x: startX + colSpacing * 2, w: colSpacing * 0.8 },
          { x: startX + colSpacing * 3, w: colSpacing * 0.8 }
        ]
      };
      const hiddenCount = Math.min(isMobile ? 1800000 : 2800000, hiddenPoints.length * (isMobile ? 24 : 28));
      const hiddenTargets = new Float32Array(hiddenCount * 3);
      const hiddenSeeds = new Float32Array(hiddenCount);
      const hiddenTones = new Float32Array(hiddenCount);
      const hiddenAltTargets = new Float32Array(hiddenCount * 3);
      for (let i = 0; i < hiddenCount; i++) {
        const p = hiddenPoints[Math.floor(Math.random() * hiddenPoints.length)];
        hiddenTargets[i * 3] = p.x;
        hiddenTargets[i * 3 + 1] = p.y;
        hiddenTargets[i * 3 + 2] = 0.0;
        hiddenSeeds[i] = Math.random();
        hiddenTones[i] = 0.85 + Math.random() * 0.15;
      }
      hiddenAltTargets.set(hiddenTargets);
      for (let i = hiddenCount - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const i3 = i * 3;
        const j3 = j * 3;
        const tx = hiddenAltTargets[i3];
        const ty = hiddenAltTargets[i3 + 1];
        const tz = hiddenAltTargets[i3 + 2];
        hiddenAltTargets[i3] = hiddenAltTargets[j3];
        hiddenAltTargets[i3 + 1] = hiddenAltTargets[j3 + 1];
        hiddenAltTargets[i3 + 2] = hiddenAltTargets[j3 + 2];
        hiddenAltTargets[j3] = tx;
        hiddenAltTargets[j3 + 1] = ty;
        hiddenAltTargets[j3 + 2] = tz;
      }
      layers.hiddenText = createLayer(hiddenTargets, hiddenSeeds, hiddenTones, hiddenAltTargets);

      const constellationCount = Math.min(9000, Math.floor(particleCount * 0.02));
      const constTargets = new Float32Array(constellationCount * 3);
      const constSeeds = new Float32Array(constellationCount);
      const constTones = new Float32Array(constellationCount);
      for (let i = 0; i < constellationCount; i++) {
        constTargets[i * 3] = (Math.random() * 2 - 1) * 1.4;
        constTargets[i * 3 + 1] = (Math.random() * 2 - 1) * 1.4;
        constTargets[i * 3 + 2] = 0.0;
        constSeeds[i] = Math.random();
        constTones[i] = 0.15 + Math.random() * 0.35;
      }
      layers.constellation = createLayer(constTargets, constSeeds, constTones, constTargets);

      gl.uniform1f(uniforms.pixelRatio, dpr);
    }

    let resizeHandle = null;
    function handleResize() {
      updateIsMobile();
      if (resizeHandle) cancelAnimationFrame(resizeHandle);
      resizeHandle = requestAnimationFrame(() => {
        initParticles();
      });
    }

    window.addEventListener('resize', handleResize);

    const warpToggle = document.getElementById('warpToggle');
    if (warpToggle) {
      warpToggle.textContent = warpEnabled ? 'Warp On' : 'Warp Off';
      warpToggle.addEventListener('click', () => {
        warpEnabled = !warpEnabled;
        warpToggle.textContent = warpEnabled ? 'Warp On' : 'Warp Off';
        if (warpEnabled) {
          prepareLogoMask();
          initWarp();
        }
      });
    }

    function prepareLogoMask() {
      logoMask = null;
      warpMaskPoints = [];
      if (!logoRectCss || !imageLoaded || !imageAsset.width) return;
      const maskCanvas = document.createElement('canvas');
      maskCanvas.width = Math.max(1, Math.floor(logoRectCss.w));
      maskCanvas.height = Math.max(1, Math.floor(logoRectCss.h));
      const maskCtx = maskCanvas.getContext('2d');
      maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
      maskCtx.drawImage(imageAsset, 0, 0, maskCanvas.width, maskCanvas.height);
      const data = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height).data;
      logoMask = data;
      logoMaskW = maskCanvas.width;
      logoMaskH = maskCanvas.height;
      const step = 3;
      for (let y = 0; y < logoMaskH; y += step) {
        for (let x = 0; x < logoMaskW; x += step) {
          const idx = (y * logoMaskW + x) * 4;
          const alpha = logoMask[idx + 3] / 255;
          const lum = logoMask[idx] * 0.299 + logoMask[idx + 1] * 0.587 + logoMask[idx + 2] * 0.114;
          if (alpha > 0.2 && lum > 60) {
            warpMaskPoints.push({ x, y });
          }
        }
      }
    }

    function pickWarpPoint() {
      if (!logoRectCss || warpMaskPoints.length === 0) {
        return { x: logoRectCss?.x ?? 0, y: logoRectCss?.y ?? 0 };
      }
      const pt = warpMaskPoints[Math.floor(Math.random() * warpMaskPoints.length)];
      return {
        x: logoRectCss.x + (pt.x + 0.5) / logoMaskW * logoRectCss.w,
        y: logoRectCss.y + (pt.y + 0.5) / logoMaskH * logoRectCss.h
      };
    }

    function initWarp() {
      if (!logoRectCss || !logoMask || warpMaskPoints.length === 0) return;
      warpCenter = {
        x: logoRectCss.x + logoRectCss.w * 0.5,
        y: logoRectCss.y + logoRectCss.h * 0.5
      };
      const baseCount = Math.min(1600, Math.max(420, Math.floor((logoRectCss.w * logoRectCss.h) / 2200)));
      const targetCount = Math.max(200, Math.floor(baseCount * 0.7));
      warpStars = [];
      for (let i = 0; i < targetCount; i++) {
        const p = pickWarpPoint();
        let dx = p.x - warpCenter.x;
        let dy = p.y - warpCenter.y;
        const len = Math.hypot(dx, dy);
        if (len < 1) {
          const angle = Math.random() * Math.PI * 2;
          dx = Math.cos(angle);
          dy = Math.sin(angle);
        } else {
          dx /= len;
          dy /= len;
        }
        warpStars.push({
          x: p.x,
          y: p.y,
          dirX: dx,
          dirY: dy,
          age: Math.random() * 0.15,
          v0: 40 + Math.random() * 80,
          alpha: 0.35 + Math.random() * 0.45,
          tint: 0.86 + Math.random() * 0.12
        });
      }
    }

    function updateWarp(dt) {
      if (!logoRectCss || warpStars.length === 0) return;
      const target = warpEnabled ? 1 : 0;
      warpIntensity += (target - warpIntensity) * Math.min(1, dt * 4.0);
      if (warpIntensity < 0.02) {
        warpCtx.clearRect(0, 0, warpCanvas.width, warpCanvas.height);
        return;
      }
      warpCtx.clearRect(0, 0, warpCanvas.width, warpCanvas.height);
      warpCtx.globalCompositeOperation = 'lighter';
      const mode = smoothstep(0.2, 0.85, warpEngage);
      const maxDim = Math.max(warpCanvas.width, warpCanvas.height);
      for (const p of warpStars) {
        p.age += dt;
        const starSpeed = p.v0 * (0.12 + 0.25 * warpIntensity);
        const hyperSpeed = p.v0 * Math.exp(1.7 * (p.age + mode * 0.45)) * (1 + mode * 1.6);
        const speed = starSpeed * (1 - mode) + hyperSpeed * mode;
        p.x += p.dirX * speed * dt;
        p.y += p.dirY * speed * dt;
        const distN = Math.min(1, Math.hypot(p.x - warpCenter.x, p.y - warpCenter.y) / maxDim);
        const trailBase = 2 + speed * 0.06;
        const trail = Math.min(maxDim * 1.2, trailBase * (1 + mode * 9.0) * (0.45 + distN));
        const thickness = Math.min(2.6, 0.45 + speed * 0.008 + mode * 0.7);
        const warpFade = Math.max(0.05, 1 - warpScroll);
        const brightness = Math.min(0.98, p.alpha * (0.55 + 0.85 * warpIntensity + 1.0 * mode) * warpFade);
        const r = Math.floor(225 + 20 * p.tint);
        const g = Math.floor(240 + 12 * p.tint);
        const b = 255;
        warpCtx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${brightness.toFixed(3)})`;
        warpCtx.lineWidth = thickness;

        if (
          p.x < -100 || p.x > warpCanvas.width + 100 ||
          p.y < -100 || p.y > warpCanvas.height + 100
        ) {
          const next = pickWarpPoint();
          p.x = next.x;
          p.y = next.y;
          let dx = p.x - warpCenter.x;
          let dy = p.y - warpCenter.y;
          const len = Math.hypot(dx, dy);
          if (len < 1) {
            const angle = Math.random() * Math.PI * 2;
            dx = Math.cos(angle);
            dy = Math.sin(angle);
          } else {
            dx /= len;
            dy /= len;
          }
          p.dirX = dx;
          p.dirY = dy;
          p.age = 0;
          p.v0 = 40 + Math.random() * 80;
          continue;
        }

        warpCtx.globalAlpha = 1;
        warpCtx.beginPath();
        if (mode < 0.15) {
          const dot = 1.2 + distN * 1.6;
          warpCtx.moveTo(p.x, p.y);
          warpCtx.lineTo(p.x + p.dirX * dot, p.y + p.dirY * dot);
        } else {
          warpCtx.moveTo(p.x - p.dirX * trail, p.y - p.dirY * trail);
          warpCtx.lineTo(p.x, p.y);
        }
        warpCtx.stroke();
      }
      warpCtx.globalCompositeOperation = 'source-over';
    }
    function toNdc(x, y) {
      const nx = (x / window.innerWidth) * 2 - 1;
      const ny = 1 - (y / window.innerHeight) * 2;
      return { x: nx, y: ny };
    }

    function addRipple(x, y) {
      const ndc = toNdc(x, y);
      ripples.push({ x: ndc.x, y: ndc.y, age: 0 });
      if (ripples.length > MAX_RIPPLES) {
        ripples.shift();
      }
    }

    function isInLogoRect(x, y) {
      if (!logoRectCss) return false;
      return x >= logoRectCss.x && x <= logoRectCss.x + logoRectCss.w &&
        y >= logoRectCss.y && y <= logoRectCss.y + logoRectCss.h;
    }

    function initWhoosh() {
      if (whooshCtx) return;
      whooshCtx = new (window.AudioContext || window.webkitAudioContext)();
      whooshGain = whooshCtx.createGain();
      whooshGain.gain.value = 1.0;
      whooshGain.connect(whooshCtx.destination);
      loadWhooshBuffer();
    }

    function loadWhooshBuffer() {
      if (whooshBuffer || whooshLoading || !whooshCtx) return;
      whooshLoading = true;
      const url = 'media/audio/Alien take off whoosh.mp3';
      const decode = (buf) => whooshCtx.decodeAudioData(buf).then((decoded) => {
        whooshBuffer = decoded;
        const rev = whooshCtx.createBuffer(decoded.numberOfChannels, decoded.length, decoded.sampleRate);
        for (let ch = 0; ch < decoded.numberOfChannels; ch++) {
          const src = decoded.getChannelData(ch);
          const dst = rev.getChannelData(ch);
          for (let i = 0, j = src.length - 1; i < src.length; i++, j--) {
            dst[i] = src[j];
          }
        }
        whooshBufferRev = rev;
        whooshLoading = false;
        if (whooshPendingDown) {
          whooshPendingDown = false;
          playWhoosh(false);
        }
        if (whooshPendingUp) {
          whooshPendingUp = false;
          playWhoosh(true);
        }
      });

      fetch(url)
        .then((res) => res.arrayBuffer())
        .then((buf) => decode(buf))
        .catch(() => {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', url, true);
          xhr.responseType = 'arraybuffer';
          xhr.onload = () => {
            if (xhr.response) {
              decode(xhr.response);
            } else {
              whooshLoading = false;
            }
          };
          xhr.onerror = () => {
            whooshLoading = false;
          };
          xhr.send();
        });
    }

    function playWhoosh(reverse = false) {
      if (!audioEnabled) return;
      initWhoosh();
      if (!whooshCtx || !whooshGain || (!whooshBuffer && !whooshBufferRev)) {
        if (reverse) {
          whooshPendingUp = true;
        } else {
          whooshPendingDown = true;
        }
        return;
      }
      if (whooshCtx.state === 'suspended') {
        whooshCtx.resume();
      }
      const buffer = reverse ? whooshBufferRev : whooshBuffer;
      if (!buffer) return;
      const src = whooshCtx.createBufferSource();
      src.buffer = buffer;
      src.connect(whooshGain);
      src.start();
    }

    window.addEventListener('pointermove', (e) => {
      mouseX = e.clientX / window.innerWidth;
      mouseY = 1.0 - (e.clientY / window.innerHeight);
      mouseStrength = 1.0;
      if (isHolding) {
        holdX = e.clientX;
        holdY = e.clientY;
      }
    }, { passive: true });

    window.addEventListener('pointerdown', (e) => {
      if (e.target && e.target.closest('[data-ui]')) {
        return;
      }
      // If names are locked open, don't start a new hold - let pointerup handle the click
      if (namesLockedOpen) {
        return;
      }
      holdReleaseTime = 0;
      whooshActive = isInLogoRect(e.clientX, e.clientY);
      if (whooshActive) {
        playWhoosh(false);
      }
      isHolding = true;
      holdStart = performance.now();
      holdX = e.clientX;
      holdY = e.clientY;
      addRipple(e.clientX, e.clientY);
    }, { passive: true });

    const teamLinkedIn = [
      'https://www.linkedin.com/in/richardjhang/',
      'https://www.linkedin.com/in/tyggy/',
      'https://www.linkedin.com/in/skim725/',
      'https://www.linkedin.com/in/ariefisher/'
    ];

    function getHiddenTextColumn(x, y) {
      const W = window.innerWidth;
      const H = window.innerHeight;

      // Vertical check - must be in upper 60% of screen
      if (y > H * 0.6) return -1;

      // Horizontal check - must be in center region (15% to 85%)
      if (x < W * 0.15 || x > W * 0.85) return -1;

      // Fixed percentage boundaries based on observed text positions:
      const pct = x / W;
      if (pct < 0.40) return 0;   // Richard
      if (pct < 0.50) return 1;   // Anton
      if (pct < 0.60) return 2;   // Summer
      return 3;                    // Arie
    }

    window.addEventListener('pointerup', (e) => {
      if (e.target && e.target.closest('[data-ui]')) {
        return;
      }
      if (whooshActive) {
        playWhoosh(true);
        whooshActive = false;
      }
      const holdDuration = performance.now() - holdStart;
      const now = performance.now();
      holdReleaseStrength = Math.min(1.0, holdDuration / 900);
      isHolding = false;
      addRipple(e.clientX, e.clientY);

      const inLogoArea = e.clientY < window.innerHeight * 0.6;

      // If names are locked open, check if clicking on a name or elsewhere
      if (namesLockedOpen) {
        const col = getHiddenTextColumn(e.clientX, e.clientY);
        if (col >= 0 && col < teamLinkedIn.length) {
          // Click on a name - open LinkedIn
          if (isMobile) {
            window.location.href = teamLinkedIn[col];
          } else {
            window.open(teamLinkedIn[col], '_blank');
          }
          namesLockedOpen = false;
        } else {
          // Click elsewhere - close names
          namesLockedOpen = false;
          holdReleaseTime = now;
        }
        return;
      }

      // If held long enough to fully reveal (ripple maximized), lock names open
      if (holdReleaseStrength >= 0.85 && inLogoArea) {
        namesLockedOpen = true;
        return;
      }

      // Normal release - fade out
      holdReleaseTime = now;
    }, { passive: true });

    function smoothstep(edge0, edge1, x) {
      const t = Math.min(1, Math.max(0, (x - edge0) / (edge1 - edge0)));
      return t * t * (3 - 2 * t);
    }

    let audioEnabled = false;
    const bgAudio = new Audio();
    const warpAudio = new Audio('media/audio/Effect.Hyperspace - Fast Stutter UFO Fly By Whoosh.mp3');
    bgAudio.loop = true;
    bgAudio.preload = 'metadata';
    warpAudio.preload = 'auto';
    bgAudio.volume = 0.252;
    warpAudio.volume = 0.6;

    // Load random track from manifest
    fetch('media/audio/manifest.json')
      .then(r => r.json())
      .then(manifest => {
        const tracks = manifest['index'] || [];
        if (tracks.length > 0) {
          const track = tracks[Math.floor(Math.random() * tracks.length)];
          bgAudio.src = 'media/audio/' + track;
        }
      })
      .catch(() => {});

    function triggerHyperspaceSound() {
      if (!audioEnabled || !warpEnabled) return;
      try {
        warpAudio.currentTime = 0;
        warpAudio.play();
      } catch (err) {
        // Ignore play errors from autoplay restrictions.
      }
    }

    const soundToggle = document.getElementById('soundToggle');
    if (soundToggle) {
      soundToggle.textContent = 'Sound Off';
      soundToggle.addEventListener('click', () => {
        audioEnabled = !audioEnabled;
        localStorage.setItem('soundEnabled', audioEnabled ? '1' : '0');
        if (audioEnabled) {
          bgAudio.currentTime = 0;
          bgAudio.play().catch(() => {});
          initWhoosh();
          if (whooshCtx && whooshCtx.state === 'suspended') {
            whooshCtx.resume();
          }
        } else {
          bgAudio.pause();
          bgAudio.currentTime = 0;
        }
        soundToggle.textContent = audioEnabled ? 'Sound On' : 'Sound Off';
      });
    }

    window.addEventListener('DOMContentLoaded', () => {
    const videoModal = document.getElementById('videoModal');
    const videoPlayer = document.getElementById('videoPlayer');
    const videoClose = document.getElementById('videoClose');
    const videoCards = document.querySelectorAll('.video-card');
    function stopSiteAudio() {
      audioEnabled = false;
      bgAudio.pause();
      bgAudio.currentTime = 0;
      warpAudio.pause();
      warpAudio.currentTime = 0;
      if (soundToggle) {
        soundToggle.textContent = 'Sound Off';
      }
    }

    function openVideo(src) {
      if (!videoModal || !videoPlayer) return;
      stopSiteAudio();
      videoPlayer.src = src;
      videoModal.classList.add('is-open');
      videoModal.setAttribute('aria-hidden', 'false');
    }

    function closeVideo() {
      if (!videoModal || !videoPlayer) return;
      videoPlayer.src = '';
      videoModal.classList.remove('is-open');
      videoModal.setAttribute('aria-hidden', 'true');
    }

    videoCards.forEach((card) => {
      card.addEventListener('click', () => {
        const src = card.getAttribute('data-video');
        if (src) openVideo(src);
      });
    });

    if (videoClose) {
      videoClose.addEventListener('click', closeVideo);
    }
    if (videoModal) {
      videoModal.addEventListener('click', (event) => {
        if (event.target === videoModal) {
          closeVideo();
        }
      });
    }
    window.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        closeVideo();
      }
    });
    });

    gl.clearColor(0, 0, 0, 1);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.disable(gl.DEPTH_TEST);

    let booted = false;
    function safeBoot() {
      if (booted) return;
      booted = true;
      initParticles();
      const sections = document.querySelectorAll('.section');
      const observer = new IntersectionObserver((entries) => {
        for (const entry of entries) {
          if (entry.isIntersecting) {
            entry.target.classList.add('is-visible');
            observer.unobserve(entry.target);
          }
        }
      }, { threshold: 0.2 });
      sections.forEach((section) => observer.observe(section));
      render();
    }

    imageAsset.onload = () => {
      imageLoaded = true;
      if (booted) {
        initParticles();
      } else {
        safeBoot();
      }
    };

    imageAsset.onerror = () => {
      console.warn('Logo image failed to decode. Falling back to text.');
      imageLoaded = false;
      safeBoot();
    };

    setTimeout(() => {
      if (!booted) {
        console.warn('Logo image load timeout. Falling back to text.');
        imageLoaded = false;
        safeBoot();
      }
    }, 1200);

    imageAsset.src = imageData;
    safeBoot();

    function render() {
      const now = performance.now();
      const t = (now - startTime) / 1000;
      const dt = (now - lastTime) / 1000;
      lastTime = now;

      const chaosDuration = 0.0;
      const convergeDuration = isMobile ? 1.0 : 2.4;
      const lockDuration = isMobile ? 0.5 : 1.2;

      let converge = 0;
      let lock = 0;
      if (t > chaosDuration) {
        converge = Math.min(1, (t - chaosDuration) / convergeDuration);
        lock = Math.min(1, Math.max(0, (t - chaosDuration - convergeDuration) / lockDuration));
      }

      const postStart = chaosDuration + convergeDuration + lockDuration;

      const scan = Math.sin(t * 0.2) * 0.9;
      let cuePassedCenter = false;
      const cueEl = document.querySelector('.intro-cue');
      if (cueEl) {
        const cueRect = cueEl.getBoundingClientRect();
        const cueCenter = cueRect.top + cueRect.height * 0.5;
        cuePassedCenter = cueCenter < window.innerHeight * 0.5;
      }
      let sectionAtCenter = false;
      const firstSection = document.querySelector('.section');
      if (firstSection) {
        const sectionRect = firstSection.getBoundingClientRect();
        const sectionTop = sectionRect.top;
        sectionAtCenter = sectionTop < window.innerHeight * 0.5;
      }
      let introOverLogo = false;
      const taglineEl = document.getElementById('tagline');
      if (taglineEl && logoRectCss) {
        const taglineRect = taglineEl.getBoundingClientRect();
        introOverLogo = taglineRect.top < (logoRectCss.y + logoRectCss.h);
      }
      const scrollMax = Math.max(1, document.body.scrollHeight - window.innerHeight);
      const scrollRaw = Math.min(1, Math.max(0, window.scrollY / scrollMax));
      const scroll = Math.min(1, scrollRaw / (isMobile ? 0.2 : 0.35));
      const scrollDark = sectionAtCenter ? 1.5 : (introOverLogo ? 1.5 : (cuePassedCenter ? 1 : scroll));
      warpScroll = scroll;

      // Track idle state at top
      const atTop = scrollRaw < 0.02;
      const scrollChanged = Math.abs(window.scrollY - lastScrollY) > 1;
      lastScrollY = window.scrollY;
      if (scrollChanged || isHolding || mouseStrength > 0.1) {
        lastInteractionTime = now;
        idleAtTopStart = 0;
      }
      if (atTop && idleAtTopStart === 0 && (now - lastInteractionTime) > 500) {
        idleAtTopStart = now;
      }
      if (!atTop) {
        idleAtTopStart = 0;
      }
      const idleDuration = idleAtTopStart > 0 ? (now - idleAtTopStart) / 1000 : 0;
      const settleMultiplier = idleAtTopStart > 0 ? Math.max(0.02, 1 - idleDuration / 1.5) : 1.0;

      mouseStrength = Math.max(0.0, mouseStrength - 0.04);
      if (scrollRaw > 0.05 && !isHolding) {
        mouseStrength = 0.0;
      }
      if (cuePassedCenter) {
        mouseStrength = 0.0;
      }

      let holdStrength = 0.0;
      let holdPos = { x: 0.0, y: 0.0 };
      if (isHolding) {
        holdStrength = Math.min(1.0, (now - holdStart) / 900);
        holdPos = toNdc(holdX, holdY);
      } else if (namesLockedOpen) {
        // Names are locked open - keep fully visible
        holdStrength = 1.0;
        holdPos = toNdc(holdX, holdY);
      } else if (holdReleaseTime > 0) {
        const elapsed = (now - holdReleaseTime) / 1000;
        const closeDuration = 1.7;
        if (elapsed < closeDuration) {
          const t = 1 - (elapsed / closeDuration);
          holdStrength = holdReleaseStrength * t;
          holdPos = toNdc(holdX, holdY);
        } else {
          holdReleaseTime = 0;
        }
      }
      if (cuePassedCenter) {
        holdStrength = 0.0;
        namesLockedOpen = false;
      }

      for (let i = ripples.length - 1; i >= 0; i--) {
        ripples[i].age += dt;
        if (ripples[i].age > rippleLife) {
          ripples.splice(i, 1);
        }
      }
      let rippleIntensity = 0;
      for (let i = 0; i < MAX_RIPPLES; i++) {
        rippleAges[i] = -1.0;
        ripplePositions[i * 2] = 0;
        ripplePositions[i * 2 + 1] = 0;
      }
      for (let i = 0; i < ripples.length; i++) {
        ripplePositions[i * 2] = ripples[i].x;
        ripplePositions[i * 2 + 1] = ripples[i].y;
        rippleAges[i] = ripples[i].age;
        rippleIntensity += Math.exp(-ripples[i].age * 1.12);
      }
      const reveal = Math.min(1, rippleIntensity * 0.18 + holdStrength * 0.6);

      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.useProgram(program);
      gl.uniform1f(uniforms.time, t);
      gl.uniform1f(uniforms.converge, converge);
      gl.uniform1f(uniforms.lock, lock);
      gl.uniform1f(uniforms.scan, scan);
      gl.uniform1f(uniforms.scroll, scrollDark);
      gl.uniform1f(uniforms.calm, (isMobile ? 0.35 : 1.0) * (cuePassedCenter ? 0.12 : 1.0) * settleMultiplier);
      gl.uniform1f(uniforms.scrollFrag, scroll);
      gl.uniform2f(uniforms.mouse, mouseX, mouseY);
      gl.uniform1f(uniforms.mouseStrength, mouseStrength);
      gl.uniform2f(uniforms.holdPos, holdPos.x, holdPos.y);
      gl.uniform1f(uniforms.holdStrength, holdStrength);
      gl.uniform2fv(uniforms.ripples, ripplePositions);
      gl.uniform1fv(uniforms.rippleAges, rippleAges);
      const holeRadius = holdStrength > 0 ? (0.12 + holdStrength * 0.28) : 0.0;
      const holeProgress = holdStrength > 0 ? Math.min(1, holdStrength) : 0.0;
      gl.uniform2f(uniforms.holePos, mouseX * 2.0 - 1.0, mouseY * 2.0 - 1.0);
      gl.uniform1f(uniforms.holeRadius, holeRadius);
      gl.uniform1f(uniforms.holeProgress, holeProgress);

      const tagline = document.getElementById('tagline');
      if (tagline) {
        const fade = Math.min(1, Math.max(0, (converge - 0.15) / 0.85));
        const introFade = 1 - Math.min(1, Math.max(0, scrollRaw / 0.35));
        tagline.style.opacity = (fade * introFade).toFixed(3);
      }
      const contact = document.querySelector('.contact');
      if (contact) {
        const introFade = 1 - Math.min(1, Math.max(0, scrollRaw / 0.35));
        contact.style.opacity = introFade.toFixed(3);
      }
      const introCue = document.querySelector('.intro-cue');
      if (introCue) {
        introCue.style.opacity = '1';
        const cueRect = introCue.getBoundingClientRect();
        const cueCenter = cueRect.top + cueRect.height * 0.5;
        const fadeTop = 1 - Math.max(0, Math.min(1, cueCenter / window.innerHeight));
        introCue.style.setProperty('--fade', fadeTop.toFixed(3));
      }
      const dividerCue = document.querySelector('.divider-cue');
      if (dividerCue) {
        const divRect = dividerCue.getBoundingClientRect();
        const divCenter = divRect.top + divRect.height * 0.5;
        const fadeTop = 1 - Math.max(0, Math.min(1, divCenter / window.innerHeight));
        dividerCue.style.setProperty('--fade', fadeTop.toFixed(3));
      }
      if (introCue) {
        const cueRect = introCue.getBoundingClientRect();
        const cueCenter = cueRect.top + cueRect.height * 0.5;
        const centerY = window.innerHeight * 0.5;
        const range = window.innerHeight * 0.12;
        const dist = Math.abs(cueCenter - centerY);
        const inZone = dist < range;
        if (inZone && !warpEngaged) {
          warpEngaged = true;
          warpEngageTime = now;
          triggerHyperspaceSound();
        }
        if (!inZone) {
          warpEngaged = false;
        }
      }
      if (warpEngageTime > 0) {
        const elapsed = (now - warpEngageTime) / 1000;
        warpEngage = Math.max(0, 1 - elapsed / 1.6);
      } else {
        warpEngage = 0;
      }
      const scrollCue = document.getElementById('scrollCue');
      if (scrollCue) {
        scrollCue.style.opacity = (1 - scroll).toFixed(3);
      }

      const bodyTextItems = document.querySelectorAll('.section p, .metric-body');
      if (bodyTextItems.length) {
        const centerY = window.innerHeight * 0.5;
        const falloff = window.innerHeight * 0.45;
        bodyTextItems.forEach((item) => {
          const rect = item.getBoundingClientRect();
          const itemCenter = rect.top + rect.height * 0.5;
          const dist = Math.min(1, Math.abs(itemCenter - centerY) / falloff);
          const bright = 1 - dist;
          const shade = 0.28 + bright * 0.55;
          item.style.color = `rgba(255, 255, 255, ${shade.toFixed(3)})`;
        });
      }

      // Scroll-based dimming for headings
      const headingItems = document.querySelectorAll('.section h2, .metric h3, .metric span');
      if (headingItems.length) {
        const topZone = window.innerHeight * 0.15;
        headingItems.forEach((item) => {
          const rect = item.getBoundingClientRect();
          const itemCenter = rect.top + rect.height * 0.5;
          const fadeTop = Math.max(0, Math.min(1, itemCenter / topZone));
          const isGreen = item.tagName === 'H3';
          if (isGreen) {
            const g = Math.round(190 + fadeTop * 36);
            const r = Math.round(59 * fadeTop);
            const b = Math.round(140 * fadeTop);
            item.style.color = `rgb(${r}, ${g}, ${b})`;
          } else {
            item.style.color = `rgba(255, 255, 255, ${(0.1 + fadeTop * 0.58).toFixed(3)})`;
          }
        });
      }

      // Scroll-based dimming for team-link button
      const teamLink = document.querySelector('.team-link');
      if (teamLink) {
        const rect = teamLink.getBoundingClientRect();
        const itemCenter = rect.top + rect.height * 0.5;
        const topZone = window.innerHeight * 0.15;
        const fadeTop = Math.max(0, Math.min(1, itemCenter / topZone));
        const borderAlpha = 0.02 + fadeTop * 0.10;
        teamLink.style.borderColor = `rgba(255, 255, 255, ${borderAlpha.toFixed(3)})`;
        teamLink.style.color = `rgba(255, 255, 255, ${(0.1 + fadeTop * 0.58).toFixed(3)})`;
        const arrow = teamLink.querySelector('.arrow');
        if (arrow) {
          const g = Math.round(190 + fadeTop * 36);
          const r = Math.round(59 * fadeTop);
          const b = Math.round(140 * fadeTop);
          arrow.style.color = `rgb(${r}, ${g}, ${b})`;
        }
      }

      const portfolioItems = document.querySelectorAll('.portfolio li');
      if (portfolioItems.length) {
        const centerY = window.innerHeight * 0.5;
        const falloff = window.innerHeight * 0.45;
        portfolioItems.forEach((item) => {
          if (!item.dataset.baseFont) {
            const base = parseFloat(getComputedStyle(item).fontSize);
            item.dataset.baseFont = base.toFixed(2);
          }
          const rect = item.getBoundingClientRect();
          const itemCenter = rect.top + rect.height * 0.5;
          const dist = Math.min(1, Math.abs(itemCenter - centerY) / falloff);
          const bright = 1 - dist;
          const shade = 0.2 + bright * 0.75;
          const delta = (bright * 2 - 1) * 3;
          const baseSize = parseFloat(item.dataset.baseFont);
          item.style.fontSize = `${(baseSize + delta).toFixed(2)}px`;
          item.style.color = `rgba(255, 255, 255, ${shade.toFixed(3)})`;
        });
      }

      if (layers.constellation) {
        gl.bindVertexArray(layers.constellation.vao);
        gl.uniform1f(uniforms.layer, 1.0);
        gl.uniform1f(uniforms.pass, 0.0);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.drawArrays(gl.POINTS, 0, layers.constellation.count);
      }

      if (layers.hiddenText) {
        gl.bindVertexArray(layers.hiddenText.vao);
        gl.uniform1f(uniforms.layer, 2.0);
        gl.uniform1f(uniforms.pass, 0.0);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.drawArrays(gl.POINTS, 0, layers.hiddenText.count);
      }

      if (layers.main) {
        gl.bindVertexArray(layers.main.vao);
        gl.uniform1f(uniforms.layer, 0.0);

        gl.uniform1f(uniforms.pass, 0.0);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.drawArrays(gl.POINTS, 0, layers.main.count);

        gl.uniform1f(uniforms.pass, 1.0);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
        gl.drawArrays(gl.POINTS, 0, layers.main.count);
      }

      updateWarp(dt);

      requestAnimationFrame(render);
    }

  </script>

  <div class="video-modal" id="videoModal" aria-hidden="true">
    <div class="video-modal__panel">
      <button class="video-modal__close" type="button" id="videoClose" data-ui="true">Close</button>
      <iframe id="videoPlayer" allow="autoplay; encrypted-media" allowfullscreen></iframe>
    </div>
  </div>

</body>
</html>
